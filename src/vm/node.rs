use crate::data::Data;
use crate::multithreading::jobs::{AsyncJobScheduler, JobHandle, Scheduler};
use std::sync::{Arc, Mutex};


/// A function that is executed for a node in order to evaluate it's output
/// value.
///
/// This function takes in the node that it is being executed for This function
/// will then create a job handle using the node's scheduler instance that will
/// evaluate the node's data value based on the node's input values when it is
/// completed.
///
/// This function may be owned by multiple nodes of the same time, and thus, may
/// be executed multiple times. (Once for each node, as needed)
pub trait NodeFunction: Fn(&Arc<Node>) -> JobHandle + Send + Sync {}
impl<Func: Fn(&Arc<Node>) -> JobHandle + Send + Sync> NodeFunction for Func {}


struct NodeData {
    inputs: Option<Vec<Arc<Node>>>,
    data:   NodeDataState,
}

enum NodeDataState {
    None,
    Pending,
    Done(Arc<Data>),
}

/// A single node within a Vertex graph that can be evaluated based on it's
/// provided inputs.
pub struct Node {
    scheduler: AsyncJobScheduler,
    func:      Arc<dyn NodeFunction>,
    data:      Mutex<NodeData>,
}

impl Node {
    /// Creates a new node instance.
    ///
    /// The scheduler reference is cloned and is used by this job, as needed, in
    /// order to create job instances. The inputs are ordered for the inputs of
    /// this
    pub(crate) fn new(
        scheduler: &AsyncJobScheduler, inputs: Vec<Arc<Node>>, func: Arc<dyn NodeFunction>,
    ) -> Self {
        Node {
            scheduler: scheduler.clone(),
            func,
            data: Mutex::new(NodeData {
                inputs: Some(inputs),
                data:   NodeDataState::None,
            }),
        }
    }


    /// Gets a reference to the async job scheduler used by this node.
    pub fn get_scheduler(self: &Arc<Node>) -> AsyncJobScheduler {
        self.scheduler.clone()
    }


    /// Gets the data that was generated by this node.
    ///
    /// This value returns None if the data has not yet been generated.
    pub fn get_data(self: &Arc<Node>) -> Option<Arc<Data>> {
        let node_data = self.data.lock().unwrap();
        if let NodeDataState::Done(data) = &node_data.data {
            Some(data.clone())
        } else {
            None
        }
    }


    /// Sets the data within this node to be equal to a new data value.
    ///
    /// A node should only have data assigned to it once, from within the node
    /// function execution. If this node already has data assigned to it, this
    /// method will panic.
    pub fn set_data(self: &Arc<Node>, data: Arc<Data>) {
        let mut node_data = self.data.lock().unwrap();
        if let NodeDataState::Done(_) = node_data.data {
            panic!("Node already has data!");
        }

        // Set the inputs of the node to none in order to allow older nodes to be
        // deallocated if they no longer have any pending children nodes. This helps
        // reduce memory usage by deallocating data that no longer has any references.
        node_data.inputs = None;
        node_data.data = NodeDataState::Done(data);
    }


    /// Gets a copy of the list of input nodes for this node.
    pub fn get_inputs(self: &Arc<Node>) -> Vec<Arc<Node>> {
        let node_data = self.data.lock().unwrap();
        match &node_data.inputs {
            Some(i) => i.clone(),
            None => vec![],
        }
    }


    /// Executes the function for this node in order to evaluate it's data
    /// value based off it's inputs.
    ///
    /// If this node has already been evaluated, nothing happens and None is
    /// returned.
    pub(crate) fn execute(self: &Arc<Node>) -> Option<JobHandle> {
        let mut node_data = self.data.lock().unwrap();
        if let NodeDataState::None = node_data.data {
            node_data.data = NodeDataState::Pending;
        } else {
            return None;
        }

        drop(node_data);
        Some((self.func)(self))
    }


    /// Converts all inputs to this node into job handles, as needed, and
    /// returns a list that can be used as a job's dependencies.
    ///
    /// Inputs that have already been evaluated are not included in this job
    /// handle list.
    pub fn inputs_as_dependencies(self: &Arc<Node>) -> Vec<JobHandle> {
        let inputs = self.get_inputs();
        inputs.iter().filter_map(|node| node.execute()).collect()
    }
}


/// Represents a virtual machine execution instance that has been started.
pub struct VirtualMachineExecution {
    scheduler: AsyncJobScheduler,
    handle:    JobHandle,
    graph:     Arc<Node>,
}

impl VirtualMachineExecution {
    /// Checks if this execution instance has finished or not.
    pub fn is_done(&self) -> bool {
        self.scheduler.is_done(&self.handle)
    }


    /// Gets the output values from the graph.
    ///
    /// If the execution task has not yet finished, this method returns None.
    pub fn get_output(&self) -> Option<Arc<Data>> {
        self.graph.get_data()
    }


    /// Blocks the current thread until this virtual machine finishes execution
    /// and returns the program output.
    pub fn complete(&self) -> Arc<Data> {
        self.scheduler.wait_for_job(&self.handle);
        self.get_output().unwrap()
    }
}


/// Triggers the provided graph to be executed with a VirtualMachineExecution
/// instance on the provided async job scheduler.
///
/// The graph will be executed with no inputs. If input parameters are required,
/// the recommended approach is to wrap the target graph inside of another graph
/// where input parameters are provided to the target graph as constants.
pub fn evaluate(
    scheduler: &AsyncJobScheduler, graph: Arc<dyn NodeFunction>,
) -> VirtualMachineExecution {
    let node = Arc::new(Node::new(scheduler, vec![], graph));
    let handle = node.execute().unwrap();

    VirtualMachineExecution {
        scheduler: scheduler.clone(),
        handle,
        graph: node,
    }
}
